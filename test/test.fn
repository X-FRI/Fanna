#| The MIT License (MIT)
#| 
#| Copyright (c) 2022 Muqiu Han
#| 
#| Permission is hereby granted, free of charge, to any person obtaining a copy
#| of this software and associated documentation files (the "Software"), to deal
#| in the Software without restriction, including without limitation the rights
#| to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#| copies of the Software, and to permit persons to whom the Software is
#| furnished to do so, subject to the following conditions:
#| 
#| The above copyright notice and this permission notice shall be included in all
#| copies or substantial portions of the Software.
#| 
#| THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#| SOFTWARE.

#| (Module "test")
module test

#| (Import "std")
import std

#| (Defexpr 
#|   (Identifier "Hello")
#|   (Lambda (Args [])
#|     (Program [(Call (Identifier "Writeln") [(String "Hello World!")])])))
Hello := lambda -> { Writeln("Hello World!") }

#| (Defexpr 
#|   (Identifier "Factorial")
#|   (Lambda (Args [(Identifier "n")])
#|     (Program
#|       [(Cond (Identifier "n")
#|         (If (Call (Identifier "||") (Args [(Call (Identifier "=") (Args [(Identifier "n") (Number "1")
#|                                           (Call (Identifier "=") (Args [(Identifier "n") (Number "0")]))]))
#|           (Return (Number "1")))
#|         (Else (Return (Call (Identifier "*") (Args [(Identifier n)
#|                                                     (Call (Identifier "Factorial") (Args [(Call (Identifier "min") (Args [(Identifier "n") (Number "1")]))]))])))))))
Factorial := lambda n -> {
    | ||(=(n, 1), =(n, 0)) -> { return 1 }
    | _ -> { return *(n, Factorial(min(n, 1))) }
}

#| (Defexpr
#|   (Identifier "Test_Hello")
#|   (Lambda (Args []))
#|     (Program [(Call (Identifier "Hello") (Args []))])))
Test_Hello := lambda -> { Hello() }

#| (Defexpr
#|   (Identifier "Test_Factorial")
#|   (Lambda (Args []))
#|     (Program
#|       [(Loop (Defexpr (Identifier "n") (Number 0)) (Call (Identifier "=") (Args [(Identifier "n") (Number "16")]))
#|         (Program
#|           [(Call (Identifier "Writeln") (Args [(Identifier "n") (String "! = ") (Call (Identifier "Factorial") (Args [(Identifier "n")]))])
#|            (Call (Identifier "++") (Args [(Identifier "n")]))]))])))
Test_Factorial := lambda -> {
    loop n := 0 until =(n 16) -> {
        Writeln(n, "! = ", Factorial(n));
        ++(n);
    }
}

Main := lambda args -> {
    Writeln("Test Hello...");
    Test_Hello();

    Writeln("Test Factorial...");
    Test_Factorial();
}